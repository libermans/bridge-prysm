// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/OffchainLabs/prysm/v6/proto/prysm/v1alpha1 (interfaces: BeaconChainClient)
//
// Generated by this command:
//
//	mockgen -package=mock -destination=testing/mock/beacon_service_mock.go github.com/OffchainLabs/prysm/v6/proto/prysm/v1alpha1 BeaconChainClient
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	eth "github.com/OffchainLabs/prysm/v6/proto/prysm/v1alpha1"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// MockBeaconChainClient is a mock of BeaconChainClient interface.
type MockBeaconChainClient struct {
	ctrl     *gomock.Controller
	recorder *MockBeaconChainClientMockRecorder
	isgomock struct{}
}

// MockBeaconChainClientMockRecorder is the mock recorder for MockBeaconChainClient.
type MockBeaconChainClientMockRecorder struct {
	mock *MockBeaconChainClient
}

// NewMockBeaconChainClient creates a new mock instance.
func NewMockBeaconChainClient(ctrl *gomock.Controller) *MockBeaconChainClient {
	mock := &MockBeaconChainClient{ctrl: ctrl}
	mock.recorder = &MockBeaconChainClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBeaconChainClient) EXPECT() *MockBeaconChainClientMockRecorder {
	return m.recorder
}

// AttestationPool mocks base method.
func (m *MockBeaconChainClient) AttestationPool(ctx context.Context, in *eth.AttestationPoolRequest, opts ...grpc.CallOption) (*eth.AttestationPoolResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AttestationPool", varargs...)
	ret0, _ := ret[0].(*eth.AttestationPoolResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AttestationPool indicates an expected call of AttestationPool.
func (mr *MockBeaconChainClientMockRecorder) AttestationPool(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttestationPool", reflect.TypeOf((*MockBeaconChainClient)(nil).AttestationPool), varargs...)
}

// AttestationPoolElectra mocks base method.
func (m *MockBeaconChainClient) AttestationPoolElectra(ctx context.Context, in *eth.AttestationPoolRequest, opts ...grpc.CallOption) (*eth.AttestationPoolElectraResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AttestationPoolElectra", varargs...)
	ret0, _ := ret[0].(*eth.AttestationPoolElectraResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AttestationPoolElectra indicates an expected call of AttestationPoolElectra.
func (mr *MockBeaconChainClientMockRecorder) AttestationPoolElectra(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttestationPoolElectra", reflect.TypeOf((*MockBeaconChainClient)(nil).AttestationPoolElectra), varargs...)
}

// GetBeaconConfig mocks base method.
func (m *MockBeaconChainClient) GetBeaconConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*eth.BeaconConfig, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBeaconConfig", varargs...)
	ret0, _ := ret[0].(*eth.BeaconConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBeaconConfig indicates an expected call of GetBeaconConfig.
func (mr *MockBeaconChainClientMockRecorder) GetBeaconConfig(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBeaconConfig", reflect.TypeOf((*MockBeaconChainClient)(nil).GetBeaconConfig), varargs...)
}

// GetChainHead mocks base method.
func (m *MockBeaconChainClient) GetChainHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*eth.ChainHead, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetChainHead", varargs...)
	ret0, _ := ret[0].(*eth.ChainHead)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetChainHead indicates an expected call of GetChainHead.
func (mr *MockBeaconChainClientMockRecorder) GetChainHead(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainHead", reflect.TypeOf((*MockBeaconChainClient)(nil).GetChainHead), varargs...)
}

// GetIndividualVotes mocks base method.
func (m *MockBeaconChainClient) GetIndividualVotes(ctx context.Context, in *eth.IndividualVotesRequest, opts ...grpc.CallOption) (*eth.IndividualVotesRespond, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetIndividualVotes", varargs...)
	ret0, _ := ret[0].(*eth.IndividualVotesRespond)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetIndividualVotes indicates an expected call of GetIndividualVotes.
func (mr *MockBeaconChainClientMockRecorder) GetIndividualVotes(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndividualVotes", reflect.TypeOf((*MockBeaconChainClient)(nil).GetIndividualVotes), varargs...)
}

// GetValidator mocks base method.
func (m *MockBeaconChainClient) GetValidator(ctx context.Context, in *eth.GetValidatorRequest, opts ...grpc.CallOption) (*eth.Validator, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidator", varargs...)
	ret0, _ := ret[0].(*eth.Validator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidator indicates an expected call of GetValidator.
func (mr *MockBeaconChainClientMockRecorder) GetValidator(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidator", reflect.TypeOf((*MockBeaconChainClient)(nil).GetValidator), varargs...)
}

// GetValidatorActiveSetChanges mocks base method.
func (m *MockBeaconChainClient) GetValidatorActiveSetChanges(ctx context.Context, in *eth.GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*eth.ActiveSetChanges, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidatorActiveSetChanges", varargs...)
	ret0, _ := ret[0].(*eth.ActiveSetChanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorActiveSetChanges indicates an expected call of GetValidatorActiveSetChanges.
func (mr *MockBeaconChainClientMockRecorder) GetValidatorActiveSetChanges(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorActiveSetChanges", reflect.TypeOf((*MockBeaconChainClient)(nil).GetValidatorActiveSetChanges), varargs...)
}

// GetValidatorParticipation mocks base method.
func (m *MockBeaconChainClient) GetValidatorParticipation(ctx context.Context, in *eth.GetValidatorParticipationRequest, opts ...grpc.CallOption) (*eth.ValidatorParticipationResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidatorParticipation", varargs...)
	ret0, _ := ret[0].(*eth.ValidatorParticipationResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorParticipation indicates an expected call of GetValidatorParticipation.
func (mr *MockBeaconChainClientMockRecorder) GetValidatorParticipation(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorParticipation", reflect.TypeOf((*MockBeaconChainClient)(nil).GetValidatorParticipation), varargs...)
}

// GetValidatorPerformance mocks base method.
func (m *MockBeaconChainClient) GetValidatorPerformance(ctx context.Context, in *eth.ValidatorPerformanceRequest, opts ...grpc.CallOption) (*eth.ValidatorPerformanceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidatorPerformance", varargs...)
	ret0, _ := ret[0].(*eth.ValidatorPerformanceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorPerformance indicates an expected call of GetValidatorPerformance.
func (mr *MockBeaconChainClientMockRecorder) GetValidatorPerformance(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorPerformance", reflect.TypeOf((*MockBeaconChainClient)(nil).GetValidatorPerformance), varargs...)
}

// GetValidatorQueue mocks base method.
func (m *MockBeaconChainClient) GetValidatorQueue(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*eth.ValidatorQueue, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidatorQueue", varargs...)
	ret0, _ := ret[0].(*eth.ValidatorQueue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorQueue indicates an expected call of GetValidatorQueue.
func (mr *MockBeaconChainClientMockRecorder) GetValidatorQueue(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorQueue", reflect.TypeOf((*MockBeaconChainClient)(nil).GetValidatorQueue), varargs...)
}

// ListAttestations mocks base method.
func (m *MockBeaconChainClient) ListAttestations(ctx context.Context, in *eth.ListAttestationsRequest, opts ...grpc.CallOption) (*eth.ListAttestationsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAttestations", varargs...)
	ret0, _ := ret[0].(*eth.ListAttestationsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAttestations indicates an expected call of ListAttestations.
func (mr *MockBeaconChainClientMockRecorder) ListAttestations(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAttestations", reflect.TypeOf((*MockBeaconChainClient)(nil).ListAttestations), varargs...)
}

// ListAttestationsElectra mocks base method.
func (m *MockBeaconChainClient) ListAttestationsElectra(ctx context.Context, in *eth.ListAttestationsRequest, opts ...grpc.CallOption) (*eth.ListAttestationsElectraResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAttestationsElectra", varargs...)
	ret0, _ := ret[0].(*eth.ListAttestationsElectraResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAttestationsElectra indicates an expected call of ListAttestationsElectra.
func (mr *MockBeaconChainClientMockRecorder) ListAttestationsElectra(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAttestationsElectra", reflect.TypeOf((*MockBeaconChainClient)(nil).ListAttestationsElectra), varargs...)
}

// ListBeaconBlocks mocks base method.
func (m *MockBeaconChainClient) ListBeaconBlocks(ctx context.Context, in *eth.ListBlocksRequest, opts ...grpc.CallOption) (*eth.ListBeaconBlocksResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListBeaconBlocks", varargs...)
	ret0, _ := ret[0].(*eth.ListBeaconBlocksResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBeaconBlocks indicates an expected call of ListBeaconBlocks.
func (mr *MockBeaconChainClientMockRecorder) ListBeaconBlocks(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBeaconBlocks", reflect.TypeOf((*MockBeaconChainClient)(nil).ListBeaconBlocks), varargs...)
}

// ListBeaconCommittees mocks base method.
func (m *MockBeaconChainClient) ListBeaconCommittees(ctx context.Context, in *eth.ListCommitteesRequest, opts ...grpc.CallOption) (*eth.BeaconCommittees, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListBeaconCommittees", varargs...)
	ret0, _ := ret[0].(*eth.BeaconCommittees)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBeaconCommittees indicates an expected call of ListBeaconCommittees.
func (mr *MockBeaconChainClientMockRecorder) ListBeaconCommittees(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBeaconCommittees", reflect.TypeOf((*MockBeaconChainClient)(nil).ListBeaconCommittees), varargs...)
}

// ListIndexedAttestations mocks base method.
func (m *MockBeaconChainClient) ListIndexedAttestations(ctx context.Context, in *eth.ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*eth.ListIndexedAttestationsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListIndexedAttestations", varargs...)
	ret0, _ := ret[0].(*eth.ListIndexedAttestationsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListIndexedAttestations indicates an expected call of ListIndexedAttestations.
func (mr *MockBeaconChainClientMockRecorder) ListIndexedAttestations(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListIndexedAttestations", reflect.TypeOf((*MockBeaconChainClient)(nil).ListIndexedAttestations), varargs...)
}

// ListIndexedAttestationsElectra mocks base method.
func (m *MockBeaconChainClient) ListIndexedAttestationsElectra(ctx context.Context, in *eth.ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*eth.ListIndexedAttestationsElectraResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListIndexedAttestationsElectra", varargs...)
	ret0, _ := ret[0].(*eth.ListIndexedAttestationsElectraResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListIndexedAttestationsElectra indicates an expected call of ListIndexedAttestationsElectra.
func (mr *MockBeaconChainClientMockRecorder) ListIndexedAttestationsElectra(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListIndexedAttestationsElectra", reflect.TypeOf((*MockBeaconChainClient)(nil).ListIndexedAttestationsElectra), varargs...)
}

// ListValidatorAssignments mocks base method.
func (m *MockBeaconChainClient) ListValidatorAssignments(ctx context.Context, in *eth.ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*eth.ValidatorAssignments, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListValidatorAssignments", varargs...)
	ret0, _ := ret[0].(*eth.ValidatorAssignments)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListValidatorAssignments indicates an expected call of ListValidatorAssignments.
func (mr *MockBeaconChainClientMockRecorder) ListValidatorAssignments(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListValidatorAssignments", reflect.TypeOf((*MockBeaconChainClient)(nil).ListValidatorAssignments), varargs...)
}

// ListValidatorBalances mocks base method.
func (m *MockBeaconChainClient) ListValidatorBalances(ctx context.Context, in *eth.ListValidatorBalancesRequest, opts ...grpc.CallOption) (*eth.ValidatorBalances, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListValidatorBalances", varargs...)
	ret0, _ := ret[0].(*eth.ValidatorBalances)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListValidatorBalances indicates an expected call of ListValidatorBalances.
func (mr *MockBeaconChainClientMockRecorder) ListValidatorBalances(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListValidatorBalances", reflect.TypeOf((*MockBeaconChainClient)(nil).ListValidatorBalances), varargs...)
}

// ListValidators mocks base method.
func (m *MockBeaconChainClient) ListValidators(ctx context.Context, in *eth.ListValidatorsRequest, opts ...grpc.CallOption) (*eth.Validators, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListValidators", varargs...)
	ret0, _ := ret[0].(*eth.Validators)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListValidators indicates an expected call of ListValidators.
func (mr *MockBeaconChainClientMockRecorder) ListValidators(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListValidators", reflect.TypeOf((*MockBeaconChainClient)(nil).ListValidators), varargs...)
}

// SubmitAttesterSlashing mocks base method.
func (m *MockBeaconChainClient) SubmitAttesterSlashing(ctx context.Context, in *eth.AttesterSlashing, opts ...grpc.CallOption) (*eth.SubmitSlashingResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubmitAttesterSlashing", varargs...)
	ret0, _ := ret[0].(*eth.SubmitSlashingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubmitAttesterSlashing indicates an expected call of SubmitAttesterSlashing.
func (mr *MockBeaconChainClientMockRecorder) SubmitAttesterSlashing(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubmitAttesterSlashing", reflect.TypeOf((*MockBeaconChainClient)(nil).SubmitAttesterSlashing), varargs...)
}

// SubmitAttesterSlashingElectra mocks base method.
func (m *MockBeaconChainClient) SubmitAttesterSlashingElectra(ctx context.Context, in *eth.AttesterSlashingElectra, opts ...grpc.CallOption) (*eth.SubmitSlashingResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubmitAttesterSlashingElectra", varargs...)
	ret0, _ := ret[0].(*eth.SubmitSlashingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubmitAttesterSlashingElectra indicates an expected call of SubmitAttesterSlashingElectra.
func (mr *MockBeaconChainClientMockRecorder) SubmitAttesterSlashingElectra(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubmitAttesterSlashingElectra", reflect.TypeOf((*MockBeaconChainClient)(nil).SubmitAttesterSlashingElectra), varargs...)
}

// SubmitProposerSlashing mocks base method.
func (m *MockBeaconChainClient) SubmitProposerSlashing(ctx context.Context, in *eth.ProposerSlashing, opts ...grpc.CallOption) (*eth.SubmitSlashingResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubmitProposerSlashing", varargs...)
	ret0, _ := ret[0].(*eth.SubmitSlashingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubmitProposerSlashing indicates an expected call of SubmitProposerSlashing.
func (mr *MockBeaconChainClientMockRecorder) SubmitProposerSlashing(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubmitProposerSlashing", reflect.TypeOf((*MockBeaconChainClient)(nil).SubmitProposerSlashing), varargs...)
}
